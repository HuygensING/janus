Janus
=====

Janus stores documents and annotations on them.

Compile and run::

    mvn clean package
    ./target/appassembler/bin/janus server janus.yml

or use the Dockerfile, ``docker run -p 8080:8080 $(docker build -q .)``.


Usage with an Elasticsearch backend
-----------------------------------

Start Elasticsearch with the appropriate settings::

    cd elasticsearch-setup
    docker run -p 9200:9200 -p 9300:9300 $(docker build -q .)

Add the annotations index::

    sh put_index.sh

You can now upload an XML file to have it indexed as a document with one
annotation per tag::

    curl -X POST http://localhost:8080/putxml/some_id -d @somefile.xml
    curl http://localhost:8080/get/some_id

Add an annotation::

    curl -H 'Content-Type: application/json' -X POST \
        http://localhost:8080/annotate/somefile.xml -d '{
            "start": 4, "end": 10, "body": "Note!", "tag": "note",
            "type": "user"
        }'

This reports the (autogenerated) id of the annotation.


REST API
--------

GET /get/{id}

Get the document with the given id and all its annotations.
Returns JSON of the form::

    {"text": string, "annotations": [annotation*]}

where an annotation is a structure of the form::

    {"start": integer,
     "end": integer,
     "attrib": map of string to string,
     "tag": string,
     "type": string,
     "target": string}

GET /getannotations/{id}?recursive={bool}

Gets the annotations for the document with the given id.
Recursive is optional and defaults to true, which means that annotations
on annotations are returned in one long list.
Returns JSON of the form::

    [annotation*]

POST /annotate/{target}/{id}

Post an annotation on the document or annotation with the {target} id.
The {id} is that of the new annotation and is optional: an id will be
generated if none is given. Returns the id of the new annotion.
If the id is already in use, an HTTP error 409 is returned.

The payload must be a JSON-encoded structure of the form::

    {"start": integer,
     "end": integer,
     "body": string,
     "attrib": map of string to string,
     "tag": string,
     "type": string}

POST /put/{id}

Post a document with the given {id}. The {id} is optional: an id will be
generated if none is given. Returns the id of the new document.
If the id is already in use, an HTTP error 409 is returned.

The payload must be a string.

POST /putxml/{id}

Post a document with the given {id}. The {id} is optional: an id will be
generated if none is given. Returns the id of the new document.
If the id is already in use, an HTTP error 409 is returned.

The payload must be an XML-encoded string. The text is stored as the document,
while the tags become annotations on this document, each with
``"type": "tag"``.

POST /transform

Performs the XML transformation that ``/putxml`` performs, without storing
anything. Useful for debugging. Output is a JSON structure of the form::

    {"text": string, "annotations": [annotation*]}

except that the ``id`` and ``type`` fields are missing in the annotations
(since nothing is stored, no ids are generated, and the type is always XML tag).


Example: bulk indexing
~~~~~~~~~~~~~~~~~~~~~~
To upload XML files in bulk for indexing, use something like::

    find some_dir -name '*.xml' -print0 |
        xargs -0 -n 1 sh -c '
            curl -s -XPOST http://localhost:8080/putxml/$(uuidgen) -d @$0
            echo " " $0
        '

This indexes all XML files below ``some_dir``, assigning to each a UUID.
It prints to stdout a list of UUID/path pairs.
